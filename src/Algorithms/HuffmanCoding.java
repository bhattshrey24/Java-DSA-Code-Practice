package Algorithms;

import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;


// Huffman coding is a message size compression algorithm . Concept is beautifully
// explained in this video - https://www.youtube.com/watch?v=co4_ahEDCho

// This algorithm uses pure greedy algorithm
// Suppose we have a message consisting of just capital alphabets and space
// like "HELLO HOW ARE YOU" now we want to send this message over internet to some other server
// so this message will be converted into bits like all the letters will be converted into their ASCII codes
// which will be then converted into bits and then transferred over internet now here comes huffman
// i.e. it will change the bits that represent each letter i.e. it will reduce the bits with which
// each character is represented based on their frequency
// i.e. based on frequency it will assign new bits to each character and then they will be sent so the size is reduced. Basically
// the logic is that if a character occurs many times then represent it will the least number of bits
// so that the size of our message is small
// and we will also send the conversion chart using which the other end of the server will decode our message
// so this algorithm will simply take a message which is made up of characters and make a chart based on
// huffman coding algorithm

public class HuffmanCoding {

    public static void main(String[] args) {
        huffmanCoding("Hello my name is Shrey"); // If frequency of a character is high then its code will be small
    }

    public static void huffmanCoding(String message) {

        char[] msgToCharArray = message.toCharArray();

        HuffmanNode[] nodes = calculateFrequency(msgToCharArray);

        PriorityQueue<HuffmanNode> pq = new PriorityQueue<>();

        for (HuffmanNode node : nodes) {
            pq.add(node);
        }

        HuffmanNode root = null; // Creating huffman tree

        while (pq.size() > 1) {

            // first min extract.
            HuffmanNode x = pq.remove();
            // second min extract.
            HuffmanNode y = pq.remove();

            // new node f which is equal sum of min 1 and min 2. And we are using character for new nodes
            // as '$' because character of new node does not matter. Observe all the leaf nodes are the actual characters
            // used in the message
            HuffmanNode f = new HuffmanNode('$', x.freq + y.freq, x, y); // x and y will be children of this new node

            // marking the f node as the root node.
            root = f;

            // add this node to the priority-queue.
            pq.add(f);
        }

        // print the codes by traversing the tree
        printCode(root, "");
    }
    public static void printCode(HuffmanNode root, String code) {
        // base case , reached leaf node , we print
        // the code generated by traversing the tree.
        if (root.left == null && root.right == null) {
            System.out.println(root.ch + ":" + code);
            return;
        }
        // simple inorder traversal of the tree and while travelling we are assigning 0 or 1 to the edge based
        // on whether we are going on left subtree or right subtree

        printCode(root.left, code + "0");
        printCode(root.right, code + "1");
    }
    public static HuffmanNode[] calculateFrequency(char[] charArray) {
        HashMap<Character, Integer> freqHM = new HashMap<>();

        //Making frequency table, where we store frequency of each letter
        for (char ch : charArray) {
            if (freqHM.containsKey(ch)) {
                freqHM.put(ch, freqHM.get(ch) + 1);
            } else {
                freqHM.put(ch, 1);
            }
        }

        // Converting hashmap into array of huffman nodes
        HuffmanNode[] nodes = new HuffmanNode[freqHM.size()];
        int i = 0;
        for (Map.Entry<Character, Integer> mapElement : freqHM.entrySet()) {
            int freq = mapElement.getValue();
            char ch = mapElement.getKey();
            nodes[i] = new HuffmanNode(ch, freq, null, null); // left and right null because initially
            // nodes are not pointing to any other nodes
            i++;
        }

        return nodes;
    }
    static class HuffmanNode implements Comparable<HuffmanNode> {

        int freq;
        char ch;

        HuffmanNode left;
        HuffmanNode right;

        HuffmanNode(char ch, int freq, HuffmanNode left, HuffmanNode right) {
            this.ch = ch;
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        @Override
        public int compareTo(@NotNull HuffmanNode o) {
            return this.freq - o.freq;
        }
    }

}
